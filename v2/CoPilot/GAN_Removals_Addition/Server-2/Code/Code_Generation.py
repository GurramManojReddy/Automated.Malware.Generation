import json
import os
import subprocess
import shutil
import zipfile
import datetime


# Global file paths
cnt_path = r"C:\Users\Win10\Desktop\Integration-Removals\Server-2\Others\count.txt"
json_path = r'C:\Users\Win10\Desktop\Integration-Removals\Server-2\Others\File.json'
BB_Initial_folder = r'C:\Users\Win10\Desktop\Integration-Removals\Server-2\Controls\BB_Initial'
BB_Final_folder = r'C:\Users\Win10\Desktop\Integration-Removals\Server-2\Controls\BB_Final'
root_folder = r"C:\Users\Win10\Desktop\Integration-Removals\Server-2"
prompts_folder = r"C:\Users\Win10\Desktop\Integration-Removals\Server-2\Controls\Prompts"
folder_to_empty = r"C:\Users\Win10\Desktop\Integration-Removals\Server-2\Controls\Generated Blocks"
checks_folder = r"C:\Users\Win10\Desktop\Integration-Removals\Server-2\Controls\Mains"
C_file_path  = r"C:\Users\Win10\Desktop\Integration-Removals\Server-2\Results\Current\code.c"
main_file_path = r"C:\Users\Win10\Desktop\Integration-Removals\Server-2\Others\Main.c"
dead_code_folder = r"C:\Users\Win10\Desktop\Integration-Removals\Server-2\Controls\DeadCode"
zip_file_path = r"C:\Users\Win10\Desktop\Integration-Removals\Server-2\Results\Code.zip"
zip_file_folder = r"C:\Users\Win10\Desktop\Integration-Removals\Server-2\Results\Current"
log_file_path = r"C:\Users\Win10\Desktop\Integration-Removals\Server-2\Results\Current\log.txt"
  

# Global variables

count = 0

# Functions

# Function to zip a folder
def zip_folder(folder_path, zip_file_path):
    with zipfile.ZipFile(zip_file_path, 'w', zipfile.ZIP_DEFLATED) as zip_file:
        for foldername, subfolders, filenames in os.walk(folder_path):
            for filename in filenames:
                file_path = os.path.join(foldername, filename)
                arcname = os.path.relpath(file_path, folder_path)
                zip_file.write(file_path, arcname)

# Function to create the code for the C file to add the dead code and newly modified blocks
def CreateContent():
    print("In the create content function...")
    global count
    with open(cnt_path, 'w') as file:
        file.write(str(count))
    content = "if(false){"
    i=0
    while i < count:
        content += f"dead{i+1}();"
        i+=1
    content += "}"
    return content

# Additional final processing function. In this function, the dead code and the newly modified blocks are added to the new c file and then compiled to create the binary
def additionalFinalProcessing():
    print("In the final processing function...")
    with open(C_file_path, 'w') as file:
        file.write("")
    content = ""
    for fn in os.listdir(BB_Final_folder):
        fp = os.path.join(BB_Final_folder, fn)
        with open(fp, 'r') as file:
            data = file.read()
        content += "\n" + data

    for fn in os.listdir(dead_code_folder):
        fp = os.path.join(dead_code_folder, fn)
        with open(fp, 'r') as file:
            data = file.read()
        content += "\n" + data

    with open(main_file_path, 'r') as file:
        data = file.read()
    with open(C_file_path, 'w') as file:
        file.write(content+"\n"+data)
    with open(C_file_path, 'r') as c_file:
        content_lines = c_file.readlines()

    # Find the position of the last closing brace '}' in the file
    last_brace_index = max((i for i, line in enumerate(content_lines) if '}' in line), default=-1)

    # Insert the printf(1); statement above the last closing brace
    print_statement = CreateContent()
    if last_brace_index >= 0:
        content_lines.insert(last_brace_index, f'    {print_statement}\n')
    else:
        # Handle the case where there is no closing brace in the file
        return

    # Write the modified content back to the file
    with open(C_file_path, 'w') as c_file:
        c_file.writelines(content_lines)

    try:
        res = subprocess.run(["gcc", C_file_path, "-o", f"{root_folder}/Results/Current/code.exe"], check=True, stderr=subprocess.DEVNULL)  
    except subprocess.CalledProcessError as e:
        print("Error While Creating the Binary.")

    #os.remove(C_file_path)
    if os.path.exists(f"{root_folder}/Results/Current/code.exe"):
        print("Binary created successfully.")
    else:
        print("No Binary.")

# Function to rename a function in a code snippet so that every function does not have the same name
def rename_function(code_snippet, old_name, new_name):
    # Replace the old function name with the new function name
    modified_code = code_snippet.replace(old_name, new_name)
    return modified_code

# Function to add the dead code to the newly created blocks
def additionPostprocess(file_path):
    global count
    print("In the postprocess function...")
    with open(file_path, 'r') as file:
        data = file.read()
    new_data = rename_function(data, "dead", f"dead{count}")
    with open(os.path.join(dead_code_folder, f"dead{count}.c"), 'w') as file:
        file.write(new_data)

# Function to preprocess the newly created blocks to add the dead code
def additionPreprocess(code_file_path):
    print("In the preprocess function...")
    with open(code_file_path, 'r') as file:
        data = file.readlines()

    # Convert the list to a string with newline characters
    data_string = ''.join(data)

    # Concatenate the strings
    new_code = data_string + f"\nint main() {{ dead(); }}\n"

    with open(f"{root_folder}/Others/current.c", 'w') as new_file:
        new_file.write(new_code)

    try:
        res = subprocess.run(["gcc", f"{root_folder}/Others/current.c", "-o", f"{root_folder}/Others/current.exe"], check=True, stderr=subprocess.DEVNULL)
    except subprocess.CalledProcessError as e:
        return False
    if os.path.exists(f"{root_folder}/Others/current.exe"):
        return True

# Function to create the prompts for the newly created blocks
def promptcreator(funcName, lib):
    global count
    print(f"Count is: {count}") 
    with open(log_file_path, 'a') as f:
        f.write(f"Starting prompt creation for {funcName},{lib}...\n")
    with open(os.path.join(root_folder, 'Others/Blocks.txt'), 'w') as file:
        file.write(f"// Code in C\n")
        file.write(f"// Code for Windows\n")
        file.write(f"// Write a function void dead() that internally calls {funcName} from the {lib} library\n")
    with open(log_file_path, 'a') as f:
        f.write(f"Starting code creation for {funcName},{lib}...\n")
    try:
        temp = subprocess.run(["python", f"{root_folder}/Code/addition_code_generation.py"])
    except subprocess.CalledProcessError as e:
        print("Error creating code.")
    with open(log_file_path, 'a') as f:
        f.write(f"Code creation for {funcName},{lib} complete...\n")
    if not len(os.listdir(folder_to_empty)) == 0:
        for fn in os.listdir(folder_to_empty):
            fp = os.path.join(folder_to_empty, fn)
            code  = additionPreprocess(fp)
            if code:
                print(f"Code {funcName},{lib} compiled successfully.")
                count = count + 1
                print(f"Count is: {count}") 
                additionPostprocess(fp)
                break
    else :
        print(f"Error creating code {funcName},{lib}")

# Function to preprocess the blocks to remove the libraries and functions from the blocks
def Removalpreprocess(i,code_file_path):
    with open(log_file_path, 'a') as f:
        f.write(f"Starting preprocess for block-{i}...\n")
    with open(code_file_path, 'r') as file:
        data = file.read()
    with open(os.path.join(checks_folder,f"{i}.c"),"r") as file:
        checks = file.read()
    new_data = data + "\n"+ checks
    with open(f"{root_folder}/Others/current.c", 'w') as new_file:
        new_file.write(new_data)
    try:
        res = subprocess.run(["gcc", f"{root_folder}/Others/current.c", "-o", f"{root_folder}/Others/current.exe"], check=True, stderr=subprocess.DEVNULL)
    except subprocess.CalledProcessError as e:
        return False
    if os.path.exists(f"{root_folder}/Others/current.exe"):
        return True
    return False

#  This function will call the other removal functions to remove the libraries and functions from the blocks and also will generate the new prompts for the blocks
    
def Remove(removals):
    for i in range(10):
        if(len(removals[i])==0):
            shutil.copy(f"{BB_Initial_folder}/{i+1}.c", f"{BB_Final_folder}/{i+1}.c")
        else :
            print(f"Writing to the prompts file for block-{i+1}...")
            with open(os.path.join(prompts_folder,f"{i+1}.txt"), 'r') as file:
                data = file.read()
            with open(os.path.join(prompts_folder,f"{i+1}.txt"), 'a') as file:
                for item in removals[i]:
                    data += f"\n// Import {item} dynamically"
                    file.write(f"\n// Import {item} dynamically")
            with open(os.path.join(root_folder, 'Others/Blocks.txt'), 'w') as file:
                file.write(data)
            with open(log_file_path, 'a') as f:
                f.write(f"Starting removal for block-{i+1}...\n")
            try:
                temp = subprocess.run(["python", f"{root_folder}/Code/removal_code_generation.py"])
            except subprocess.CalledProcessError as e:
                print("Error Creating Code")
            if not len(os.listdir(folder_to_empty)) == 0:
                with open(log_file_path, 'a') as f:
                    f.write(f"Removing the block-{i+1}...\n")
                for fn in os.listdir(folder_to_empty):
                    fp = os.path.join(folder_to_empty, fn)
                    if(Removalpreprocess(i+1,fp)):
                        shutil.copy(fp, f"{BB_Final_folder}/{i+1}.c")
                        break
            if not os.path.exists(f"{BB_Final_folder}/{i+1}.c"):
                with open(log_file_path, 'a') as f:
                    f.write(f"Unable to create block-{i+1}.c. So,Copying the initial block-{i+1}.c\n")
                print(f"Unable to create block-{i+1}.c. So,Copying the initial block-{i+1}.c")
                shutil.copy(f"{BB_Initial_folder}/{i+1}.c", f"{BB_Final_folder}/{i+1}.c")

# Function to check if a function is present in a file
def RemoveCheck(file_path, funcName):
    with open(file_path, 'r') as file:
        data = file.read()
    if funcName in data:
        return True
    return False


# Main Function

if __name__ == '__main__':
    with open(cnt_path, 'r') as file:
        tempcnt = file.read()
    count = int(tempcnt)
    with open(json_path, 'r') as file:
        data = json.load(file)

    # Perform the removals
    print("Starting Removal Process...")
    with open(log_file_path, 'a') as f:
        f.write("Starting Removal Process...\n")
    removals = [set() for i in range(10)]
    for lib, funcNames in data["libraries_rem"].items():
        for funcName in funcNames:
            for i in range(10):
                if(RemoveCheck(os.path.join(BB_Initial_folder,f"{i+1}.c"),funcName)):
                    removals[i].add(funcName)
    Remove(removals)
    with open(log_file_path, 'a') as f:
        f.write("Removal Process Complete...\n")
    print("Removal Process Complete...")


    # Performing the deadcode addition
    with open(log_file_path, 'a') as f:
        f.write("Starting deadcode addition...\n")
    print("Starting deadcode addition...")
    for lib, funcNames in data["libraries_add"].items():
        for funcName in funcNames:
            promptcreator(funcName, lib)

    additionalFinalProcessing()
    with open(log_file_path, 'a') as f:
        f.write("Deadcode addition complete...\n")

    print('Deadcode addition complete...')
    with open(log_file_path, 'a') as f:
        f.write("Zipping the folder...\n")
    print("Zipping the folder...")
    zip_folder(zip_file_folder, zip_file_path)
    with open(log_file_path, 'a') as f:
        f.write("Zip file created successfully...\n")
    print("Zip file created successfully...")
    print("Starting to send the file...")