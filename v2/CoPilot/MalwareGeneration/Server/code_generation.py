import subprocess
import datetime
import os
import shutil
import sys
import re
import csv
import time

# Defining global variables
folder_to_empty = 'C:/Users/Win10/Desktop/Project/Generated Building Blocks'
root_folder = 'C:/Users/Win10/Desktop/Project/Controls'
csv1_file_path = f"{folder_to_empty}/Build_Blocks.csv"
# -------
# Defining global paths
csv2_file_path = f"{folder_to_empty}/Compiling_Blocks.csv"
csv3_file_path = f"{folder_to_empty}/Binaries_info.csv"
log_file_path = f"{folder_to_empty}/log.txt"
Input_VAR = 100
# Set the default encoding to UTF-8
os.environ['PYTHONENCODING'] = 'utf-8'
    


# Functions
# Function to check if the braces are balanced in the suggestions generated by copilot
def are_brackets_balanced(content):
    index = 0
    brace_count = 0

    while index < len(content):
        if content[index] == "{":
            brace_count += 1
        elif content[index] == "}":
            brace_count -= 1

        # Optimization: Exit early if unbalanced braces
        if brace_count < 0:
            return False

        index += 1

    # Check if all braces are balanced
    return brace_count == 0
# Function to remove the main function from the generated code as we are extrcting only the building blocks
def remove_main_function_c(code):
    start_index = code.find("int main")
    if start_index == -1:
        return code
    brace_start_index = code.find("{", start_index)
    if brace_start_index == -1:
        return code

    brace_count = 1
    index = brace_start_index + 1
    while index < len(code) and brace_count > 0:
        if code[index] == "{":
            brace_count += 1
        elif code[index] == "}":
            brace_count -= 1
        index += 1
    if brace_count == 0:
        code = code[:start_index] + code[index:]
    else:
        return code[:start_index]
    return code
# Function to clean up the code by removing comments and unnecessary lines
def clean_up_code(code):
    lines = code.split('\n')
    cleaned_lines = []
    count = 0

    # Flag to keep lines after an open bracket
    keep_after_open_bracket = False

    for line in lines:
        # Skip lines starting with //
        if line.strip().startswith('//'):
            continue

        # Keep lines that start with #
        if line.startswith('#'):
            cleaned_lines.append(line)
            continue

        # Keep lines with brackets
        if '(' in line or ')' in line:
            if '{' in line:
                keep_after_open_bracket = True
                count += 1
            if '}' in line and count > 0:
                count -= 1
                if count == 0:
                    keep_after_open_bracket = False
            cleaned_lines.append(line)
            continue

        # Keep lines after an open bracket
        idx = 0
        while idx < len(line):
            if line[idx] == '{':
                keep_after_open_bracket = True
                count += 1
            idx += 1

        if keep_after_open_bracket:
            cleaned_lines.append(line)

            # Reset the flag after closing bracket is found
            idx = 0
            while idx < len(line) and count > 0:
                if line[idx] == '}':
                    count -= 1
                    if count == 0:
                        keep_after_open_bracket = False
                idx += 1

    return '\n'.join(cleaned_lines)
# Function to empty the folder
def empty_folder(folder_path):
    try:
        for root, dirs, files in os.walk(folder_path):
            for file in files:
                file_path = os.path.join(root, file)
                os.remove(file_path)
            for dir in dirs:
                dir_path = os.path.join(root, dir)
                shutil.rmtree(dir_path)
        print(f"The folder '{folder_path}' has been emptied.")
    except Exception as e:
        print(f"Error while emptying the folder: {str(e)}")
# Function to remove empty lines from the input text
def remove_empty_lines(text):
    """Remove empty lines from the input text."""
    lines = [line for line in text.splitlines() if line.strip()]
    return '\n'.join(lines)
# Function to generate variations for the building blocks
def Core(Input_variations, b):
    time.sleep(1)
    l=1
    # Initialize a set to store the generated variations
    Genarated_variations = set()
    # Create a folder to store the generated variations for a particular building block
    Block_folder = f'C:/Users/Win10/Desktop/Project/Generated Building Blocks/BuildingBlock-{b}'
    if not os.path.exists(Block_folder):
        os.makedirs(Block_folder)
    count = 0 # Counter to limit the number of iterations
    print(f"Generating variations for Building Block {b}...")
    start = datetime.datetime.now()
    print(f"Started at: {start}")
    with open(log_file_path, "a") as file:
        file.write(f"Building Block {b} Started at: {start}\n")
    while len(Genarated_variations)<int(Input_variations) and count<100:
        count = count + 1
        if not os.path.exists('C:/Users/Win10/Desktop/Project/Controls'):
            os.makedirs('C:/Users/Win10/Desktop/Project/Controls')
        file_path ='C:/Users/Win10/Desktop/Project/Controls/BuildingBlock.c'
        if os.path.exists(file_path):
            os.remove(file_path)
        file_path = 'C:/Users/Win10/Desktop/Project/Controls/Suggestions.txt'  # Replace with your file path
        if os.path.exists(file_path):
            os.remove(file_path)
        # Run the Copilot automation script
        executable_path ='C:/Users/Win10/Desktop/Project/Controls/Copilot_Automation.exe'
        subprocess.run(executable_path, shell=True)
        # Initialize a list to store suggestion objects
        suggestion_objects = []
        file_path = 'C:/Users/Win10/Desktop/Project/Controls/Suggestions.txt'
        if not os.path.exists(file_path):
            # No suggestions file found, skip this iteration
            continue
        # Read the suggestions file and extract the suggestions
        try:
            file_path = 'C:/Users/Win10/Desktop/Project/Controls/Suggestions.txt'
            with open(file_path, "r", encoding='utf-8') as file:
                lines = file.readlines()
        except Exception as e:
            # Handle the exception or provide a fallback action
            file_path = 'C:/Users/Win10/Desktop/Project/Controls/Suggestions.txt'
            with open(file_path, "r") as file:
                lines = file.readlines()
        # Initialize variables to store the current suggestion and the flag to add to the suggestion
        current_suggestion = {}
        add_to_suggestion = False
        # Extract the suggestions from the file
        for line in lines:
            if line.startswith("Suggestion"):
                if current_suggestion:
                    suggestion_objects.append(current_suggestion)
                add_to_suggestion = True
                current_suggestion = {"Suggestion": line.strip()}
            elif line.startswith("======="):
                add_to_suggestion = False
            elif add_to_suggestion:
                current_suggestion["Content"] = current_suggestion.get("Content", "") + line

        # Append the last suggestion if any
        if current_suggestion:
            suggestion_objects.append(current_suggestion)

        # Extract the suggestions with balanced braces
        Suggestions = []
        for suggestion in suggestion_objects:
            temp = suggestion.get("Content", "")
            if are_brackets_balanced(temp):
                Suggestions.append(temp)
        # Clean up the suggestions
        for i in range(len(Suggestions)):
            Suggestions[i] = clean_up_code(Suggestions[i])
            Suggestions[i] = remove_main_function_c(Suggestions[i])
            if '{' in Suggestions[i]:
                Suggestions[i] = remove_empty_lines(Suggestions[i])
                Genarated_variations.add(Suggestions[i])
    # Write the generated variations to files
    for i,content in enumerate(Genarated_variations, start=1):
        if l<=int(Input_variations):
            # While generated variations are less than the input variations, create a new variation file
            file_path = f"{Block_folder}/Variation{l}.c"
            try:
                with open(file_path, "w", encoding='utf-8') as file:
                    file.write(content)
            except Exception as e:
                with open(file_path, "w") as file:
                    file.write(content)
            l+=1
    end = datetime.datetime.now()
    print(f"Finished at: {end}")
    with open(log_file_path, "a") as file:
        file.write(f"Building Block {b} Finished at: {end}\n")
    with open(csv1_file_path, mode='r', newline='') as file:
        reader = csv.reader(file)
        table_data = list(reader)

    # Update the table data with the generated variations count
    if len(Genarated_variations)< int(Input_VAR)+1:
        table_data[b][2] = len(Genarated_variations)
    else:
        table_data[b][2] = int(Input_VAR)
    table_data[b][3] = end-start
    table_data[b][4] = table_data[b][3]/table_data[b][2]

    # Write the modified data back to the CSV file
    with open(csv1_file_path, mode='w', newline='') as file:
        writer = csv.writer(file)
        writer.writerows(table_data)



if __name__ == "__main__":
    if len(sys.argv) > 1:
        input_var = sys.argv[1]
        print(f"Received input variation: {input_var}")
    else:
        print("No input variation provided.")  # Exit the script if no input variation is provided
    Input_VAR = input_var
    with open(log_file_path, "w") as file:
        file.write(f"Input variation: {input_var}\nBuilding Variations Started at: {datetime.datetime.now()}\n")

    empty_folder(folder_to_empty)

    # Reading the input file
    table_data = [
        ["BuildingBlocks", "InputVariations", "GeneratedVariations", "TimeTaken", "AvgTimeTaken"],
    ]

    for i in range(1, 11):
        row = [f"BuildingBlock-{i}", f"{input_var}", "", "", ""]
        table_data.append(row)

    with open(csv1_file_path, mode='w', newline='') as file:
        writer = csv.writer(file)
        writer.writerows(table_data)
    # Reading the input file
    with open(f"{root_folder}/BuildingBlocks.txt", "r") as input_file:
        content = input_file.readlines()
    # Defining global variables for the CSV files
    num_rows = 10
    num_columns = int(input_var)

    # Value to fill the cells with
    fill_value = 0

    with open(csv2_file_path, mode='w', newline='') as file:
        # Create a CSV writer object
        csv_writer = csv.writer(file)
        # Write the header row
        header_row = [''] + [f'Variation{i}' for i in range(1, num_columns + 1)]
        csv_writer.writerow(header_row)

    print(f'CSV file created at {csv2_file_path}')

    with open(csv3_file_path, mode='w', newline='') as file:
        # Create a CSV writer object
        csv_writer = csv.writer(file)
        header_row = [''] + [f'BuildingBlock-{i}' for i in range(1, 11)]
        csv_writer.writerow(header_row)

    #-------

    Started = False
    Input_variations = input_var
    b = 1

    for line in content:
        Input_line = line
        # Check if the line starts with a number followed by a dot and a space
        if re.match(r'^\d+\. ', Input_line):
            if Started:
                Core(Input_variations, b)           
                b+=1
            cleaned_line = re.sub(r'^\d+\. ', '', Input_line)
            with open(f"{root_folder}/Input.txt", "w") as file:
                file.write(cleaned_line)
            Started = True
        else:
            with open(f"{root_folder}/Input.txt", "a") as file:
                file.write(line)
    # Generate variations for the last building block
    Core(Input_variations, b)

    with open(log_file_path, "a") as file:
        file.write(f"Building Variations Finished at: {datetime.datetime.now()}\n")