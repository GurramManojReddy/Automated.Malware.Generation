import tempfile
import os
import subprocess
import itertools
import shutil
import re
import csv

# Define the paths
folder_to_empty = 'C:/Users/Win10/Desktop/Project/Generated Building Blocks'
Main_function_path = 'C:/Users/Win10/Desktop/Project/Controls/Main.c'
csv2_file_path = f"{folder_to_empty}/Compiling_Blocks.csv"
csv3_file_path = f"{folder_to_empty}/Binaries_info.csv"
log_file_path = f"{folder_to_empty}/log.txt"
current_file_path = "C:/Users/Win10/Desktop/Project/Controls/current.c"

# ------
# Function to append the content of a file to another file
def append_file(file1_path, file2_path):
    with open(file2_path, 'r') as file2:
        content_to_append = file2.read()

    with open(file1_path, 'a') as file1:
        file1.write(f"\n{content_to_append}")

# Adding the comments to the variations to keep track of the variations
def Commenting_variations(file_path):
    for folder_number in range(1, 11):
        folder_name = f"BuildingBlock-{folder_number}"
        folder_directory = os.path.join(file_path, folder_name)

        if os.path.exists(folder_directory):
            files = os.listdir(folder_directory)
            for file_name in files:
                file_path_inner = os.path.join(folder_directory, file_name)
                with open(file_path_inner, 'r') as file:
                    snippet = file.read()
                
                # Extract the number from the file name using a more specific regex
                match = re.search(r'Variation(\d+)\.c', file_name)
                
                if match:
                    extracted_number = int(match.group(1))
                    # Create a new content by appending the file name at the start
                    new_content = f"//-----{extracted_number}-----\n\n{snippet}"
                    
                    with open(file_path_inner, 'w') as file:
                        file.write(new_content)
                else:
                    print(f"No match found in file name: {file_name}")
# ------

# Marking the blocks in the variations to find the blocks in the code
def Marking_Blocks(file_path):
    with open(file_path, 'r') as file:
        c_content = file.read()
    
    matches = re.findall(r'-----([0-9]+)-----', c_content)
    
    # Read data from csv2_file_path

    # Append data to csv3_file_path
    with open(csv3_file_path, 'a', newline='') as file:
        # Creating a CSV writer object
        csv_writer = csv.writer(file)
        data = os.path.basename(file_path)
        data = os.path.splitext(data)[0]
        # Updating the csv file with blocks information
        row_to_append = [data] + list(map(int, matches))
        csv_writer.writerow(row_to_append)
# ------
        
# Function to compute the success rate of the building blocks
def compute_success_rate():
    # Create a temporary file to store the modified data
    temp_file_path = tempfile.mktemp(suffix=".csv", prefix="temp_", dir=os.path.dirname(csv2_file_path))

    # Read the input CSV file and write to the temporary CSV file
    with open(csv2_file_path, 'r') as input_file, open(temp_file_path, 'w', newline='') as temp_file:
        csv_reader = csv.reader(input_file)
        csv_writer = csv.writer(temp_file)

        # Iterate through each row in the input CSV file
        for i, row in enumerate(csv_reader):
            if i == 0:
                row.append('Success Rate')
                csv_writer.writerow(row)
                continue
            else:
                # Extract values from the row (excluding the first column)
                values_to_average = [float(value) for value in row[1:]]

                count_of_ones = values_to_average.count(1)

                # Calculate the success rate
                success_rate = count_of_ones / len(values_to_average) if len(values_to_average) > 0 else 0

                # Append the success rate to the end of the row
                row.append(success_rate)

                # Write the updated row to the temporary CSV file
                csv_writer.writerow(row)

    # Replace the original file with the temporary file
    shutil.move(temp_file_path, csv2_file_path)

# Function to process a combination of building blocks
def process_combination(args):
    i, combination, file_path, code_folder, binary_folder, total = args
    code_file_name = f"combination_{i}.c"
    binary_file_name = f"combination_{i}.exe"
    code_file_path = os.path.join(code_folder, code_file_name)
    binary_file_path = os.path.join(binary_folder, binary_file_name)

    with open(code_file_path, 'w') as file:
        file.write('\n'.join(combination))
    
    append_file(code_file_path, Main_function_path)

    try:
        result = subprocess.run(
            ["gcc", "-Wall","-O2", "-o", binary_file_path, code_file_path],
            check=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
        # -----
        if result.returncode == 0:
            Marking_Blocks(code_file_path)
        # -----
    except subprocess.CalledProcessError as e:
        os.remove(code_file_path)
    if i%1000 == 0:
        print(f"Processed combination {i}")
        print(f"{i/total*100}% completed")

# Function to check if a snippet is compilable
def compilable(snippet, folder_number):
    with open(current_file_path, 'w') as file:
        file.write(snippet)
    append_file(current_file_path, f"C:/Users/Win10/Desktop/Project/Controls/Main/Main-{folder_number}.c")
    current1 = 1
    try:
        result = subprocess.run(
            ["gcc", "-Wall","-O2", "-o", "C:/Users/Win10/Desktop/Project/Controls/current.exe", current_file_path],
            check=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
        if result.returncode == 0:
            current1 = 0
    except subprocess.CalledProcessError as e:
        current1 = 1
    # -----
    if current1 == 0:
        os.remove(current_file_path)
        os.remove("C:/Users/Win10/Desktop/Project/Controls/current.exe")
        return True
    else :
        os.remove(current_file_path)
        return False

# Function to process the files in parallel, i.e, to utilize multiple cores
def process_file_parallel(file_path):
    binary_folder = os.path.join(file_path, 'binary')
    os.makedirs(binary_folder, exist_ok=True)
    code_folder = os.path.join(file_path, 'code')
    os.makedirs(code_folder, exist_ok=True)

    folder_snippets = []

    for folder_number in range(1, 11):
        row_to_append = [f"BuildingBlock-{folder_number}"]
        folder_name = f"BuildingBlock-{folder_number}"
        folder_directory = os.path.join(file_path, folder_name)

        if os.path.exists(folder_directory):
            files = os.listdir(folder_directory)
            snippets = []
            for file_name in files:
                file_path_inner = os.path.join(folder_directory, file_name)
                with open(file_path_inner, 'r') as file:
                    snippet = file.read()
                if compilable(snippet, folder_number):
                    row_to_append.append(1)
                    snippets.append(snippet)
                else:
                    row_to_append.append(0)
            folder_snippets.append(snippets)
        with open(csv2_file_path, 'a', newline='') as file:
            csv_writer = csv.writer(file)
            csv_writer.writerow(row_to_append)

    combinations = list(enumerate(itertools.product(*folder_snippets), 1))
    with open(log_file_path, 'a') as file:
        file.write(f"\nNumber of combinations: {len(combinations)} \n")
    total = len(combinations)
    print(f"Number of combinations: {len(combinations)}")

if __name__ == "__main__":
    file_path = "C:/Users/Win10/Desktop/Project/Generated Building Blocks"
    Commenting_variations(file_path)
    with open(log_file_path, 'a') as file:
        file.write("Commenting the variations is done\n")
    # Process the combinations generated by the building blocks in parallel
    process_file_parallel(file_path)

    # Folder to store the binaries
    binary_folder = os.path.join(file_path, 'binary')
    if  not os.path.exists(binary_folder):
        os.makedirs(binary_folder, exist_ok=True)

    is_empty = not any(os.listdir(binary_folder)) if os.path.exists(binary_folder) else None
    
    if not is_empty:
        with open(log_file_path, 'a') as file:
            file.write("Binaries are generated \n")
    else:
        with open(log_file_path, 'a') as file:
            file.write("Binaries are not generated \n")
    # -----
    compute_success_rate()

    
