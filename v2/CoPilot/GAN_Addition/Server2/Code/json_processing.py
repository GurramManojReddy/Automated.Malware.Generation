import json
import os
import subprocess
import shutil
import zipfile
import datetime

# Define the paths
json_path = r'C:\Users\Win10\Desktop\Integration\Server2\Code\File.json'
root_folder = r"C:\Users\Win10\Desktop\Integration\Server2\Code"
folder_to_empty = r"C:\Users\Win10\Desktop\Integration\Server2\Code\Generated Blocks"
variables_path =r"C:\Users\Win10\Desktop\Integration\Extra\Current_Binary.txt" 
zip_file_folder = r"C:\Users\Win10\Desktop\Integration\Server2\Code\Results\Code"
C_file_path  = r"C:\Users\Win10\Desktop\Integration\Server2\Code\Results\Code\Binary_V1.c"
log_file_path = r"C:\Users\Win10\Desktop\Integration\Server2\Code\Results\Code\log.txt"
zip_file_path = r"C:\Users\Win10\Desktop\Integration\Server2\Code\Results\Code.zip"
Combinations_path = r"C:\Users\Win10\Desktop\Combinations"
count_path = r"C:\Users\Win10\Desktop\Integration\Extra\count.txt" 

# Define the global variables
count = 0
initial_count = 0

# Function to delete a directory and its contents
def delete_directory(directory_path):
    try:
        # Use shutil.rmtree to delete the directory and its contents recursively
        shutil.rmtree(directory_path)
        print(f"Directory '{directory_path}' deleted successfully.")
    except Exception as e:
        print(f"Error deleting directory '{directory_path}': {str(e)}")

# Function to zip a folder
def zip_folder(folder_path, zip_file_path):
    with zipfile.ZipFile(zip_file_path, 'w', zipfile.ZIP_DEFLATED) as zip_file:
        for foldername, subfolders, filenames in os.walk(folder_path):
            for filename in filenames:
                file_path = os.path.join(foldername, filename)
                arcname = os.path.relpath(file_path, folder_path)
                zip_file.write(file_path, arcname)

# Function to create the dead code line to be inserted in the C file
def CreateContent():
    global count, initial_count
    content = "if(false){"
    i=initial_count
    while i < count:
        content += f"dead{i+1}();"
        i+=1
    content += "}"
    return content

# Function to finalize the processing of the C file. In this function dead code is added to the C file and the file is compiled to create a binary
def final_processing():
    print("In the final_processing function...")
    with open(C_file_path, 'r') as c_file:
        content_lines = c_file.readlines()

    # Find the position of the last closing brace '}' in the file
    last_brace_index = max((i for i, line in enumerate(content_lines) if '}' in line), default=-1)

    # Insert the printf(1); statement above the last closing brace
    print_statement = CreateContent()
    if last_brace_index >= 0:
        content_lines.insert(last_brace_index, f'    {print_statement}\n')
    else:
        # Handle the case where there is no closing brace in the file
        return

    # Write the modified content back to the file
    with open(C_file_path, 'w') as c_file:
        c_file.writelines(content_lines)
    try:
        res = subprocess.run(["gcc", C_file_path, "-o", f"{root_folder}/Results/Code/Binary_V1.exe"], check=True, stderr=subprocess.DEVNULL)
    except subprocess.CalledProcessError as e:
        print("Error creating binary.")
        with open(log_file_path, 'a') as f:
            f.write("Error creating binary\n")
    # Check if the binary is created successfully
    if os.path.exists(f"{root_folder}/Results/Code/Binary_V1.exe"):
        print("Binary created successfully.")
        with open(variables_path, 'r') as file:
            index = file.read()
        index = int(index)
        with open(C_file_path, 'r') as c_file:
            content = c_file.read()
        c_file_path = f"{Combinations_path}/Combination-{index}.c"
        with open(c_file_path, 'w') as c_file:
            c_file.write(content)
        with open(log_file_path, 'a') as f:
            f.write("Binary created successfully\n")
        with open(count_path, 'w') as file:
            file.write(str(count))
    else:
        print("Error creating binary.")
        with open(log_file_path, 'a') as f:
            f.write("Error creating binary\n")

# Function to rename a function in the code snippet
def rename_function(code_snippet, old_name, new_name):
    # Replace the old function name with the new function name
    modified_code = code_snippet.replace(old_name, new_name)
    return modified_code

# Function to preprocess the code snippet by modifying it and adding a main C file
def postprocess(file_path):
    print("In the postprocess function...")
    with open(file_path, 'r') as file:
        data = file.read()
    new_data = rename_function(data, "dead", f"dead{count}")
    with open(C_file_path, 'r') as file:
        initial_count = file.read()
    new_cnt = new_data + "\n"+ initial_count
    with open(C_file_path, 'w') as file:
        file.write(new_cnt)

# Function to preprocess the code snippet and compiling it to check if it is valid   
def preprocess(code_file_path):
    #print(temp)
    print("In the preprocess function...")
    with open(code_file_path, 'r') as file:
        data = file.readlines()

    # Convert the list to a string with newline characters
    data_string = ''.join(data)

    # Concatenate the strings
    new_code = data_string + f"\nint main() {{ dead(); }}\n"
    #print(new_code)

    with open(f"{root_folder}/temp.c", 'w') as new_file:
        new_file.write(new_code)
    if os.path.exists(f"{root_folder}/temp.exe"):
        os.remove(f"{root_folder}/temp.exe")

    try:
        res = subprocess.run(["gcc", f"{root_folder}/temp.c", "-o", f"{root_folder}/temp.exe"], check=True, stderr=subprocess.DEVNULL)
    except subprocess.CalledProcessError as e:
        return False
    if os.path.exists(f"{root_folder}/temp.exe"):
        return True
    return False

# Function to create the prompt for the copilot to create the dead code
def promptcreator(b, item, key):
    global count
    with open(os.path.join(root_folder, 'Blocks.txt'), 'w') as file:
        file.write(f"// Code in C\n")
        file.write(f"// Code for Windows\n")
        file.write(f"// Write a function void dead() that internally calls {item} from the {key} library\n")
    with open(log_file_path, 'a') as f:
        f.write(f"Processing pair {item},{key}\n")
        start = datetime.datetime.now()
        f.write(f"Started at: {start}\n")
    try:
        temp = subprocess.run(["python", f"{root_folder}/code_generation.py"])
    except subprocess.CalledProcessError as e:
        print("Error creating code.")
        with open(log_file_path, 'a') as f:
            f.write(f"Error creating code {item},{key}\n")
            f.write(f"Finished at: {datetime.datetime.now()}\n")
            f.write(f"Time taken: {datetime.datetime.now() - start}\n")
        return
    if not len(os.listdir(folder_to_empty)) == 0:
        print(f"Count is :{count}")
        for fn in os.listdir(folder_to_empty):
            fp = os.path.join(folder_to_empty, fn)
            code  = preprocess(fp)
            if code:
                with open(log_file_path, 'a') as f:
                    f.write(f"Code {item},{key} compiled successfully.\n")
                    f.write(f"Finished at: {datetime.datetime.now()}\n")
                    f.write(f"Time taken: {datetime.datetime.now() - start}\n")
                print(f"Code {item},{key} compiled successfully.")
                count = count + 1
                postprocess(fp)
                return
        with open(log_file_path, 'a') as f:
            f.write(f"Error compiling code {item},{key}\n")
            f.write(f"Finished at: {datetime.datetime.now()}\n")
            f.write(f"Time taken: {datetime.datetime.now() - start}\n")
        print(f"Error compiling code {item},{key}")
    else :
        with open(log_file_path, 'a') as f:
            f.write(f"Error creating code {item},{key}\n")
            f.write(f"Finished at: {datetime.datetime.now()}\n")
            f.write(f"Time taken: {datetime.datetime.now() - start}\n")
        print(f"Error creating code {item},{key}")
              
if __name__ == '__main__':

    # Reading the index from the file
    with open(variables_path, 'r') as file:
        index = file.read()
    with open(count_path, 'r') as file:
        tempcnt = file.read()
    count = int(tempcnt)
    initial_count = int(tempcnt)
    index = int(index)

    # Copy the C file to the Results folder
    c_file_path = f"{Combinations_path}/Combination-{index}.c"
    with open(c_file_path, 'r') as c_file:
        content_lines = c_file.readlines()
    os.makedirs(zip_file_folder, exist_ok=True)
    with open(C_file_path, 'w') as c_file:
        c_file.writelines(content_lines)

    # Reading the JSON file
    with open(json_path, 'rb') as file:
        data = json.load(file)
    print("Processing JSON...")
    
    i=1
    for key, value in data["libraries"].items():
        for item in value:
            # Creating prompts for the given pair to add as dead code
            promptcreator(i,item, key)
            i+=1
    with open(log_file_path, 'a') as f:
        f.write("JSON Processing Complete\n")
    if count - int(initial_count) > 0:
        with open(log_file_path, 'a') as f:
            f.write("Additional code is added, Creating a new binary\n")
        print("Final Processing...")
        final_processing()
    else :
        with open(log_file_path, 'a') as f:
            f.write("No additional code to add\n")
    print("Zipping the folder...")
    zip_folder(zip_file_folder, zip_file_path)
    delete_directory(zip_file_folder)
    