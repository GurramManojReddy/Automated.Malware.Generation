import subprocess
import datetime
import os
import shutil
import re

# Defining the paths
folder_to_empty = r"C:\Users\Win10\Desktop\Integration\Server2\Code\Generated Blocks"
root_folder = r'C:\Users\Win10\Desktop\Integration\Server2\Code'
log_file_path = r"C:\Users\Win10\Desktop\Integration\Server2\Code\Results\Code\log.txt"

# Global variables
Input_VAR = 100

# Functions

# Function to extract headers from a C code snippet
def extract_headers(code_snippet):
    # Define a regular expression pattern to match C headers
    pattern = r'#include\s*<.*?>|#include\s*".*?"'
    
    # Use findall to extract all occurrences of the pattern in the code snippet
    headers = re.findall(pattern, code_snippet)
    
    return headers

# Function to extract the dead() function from a C code snippet
def extract_dead_function(code_snippet):
    # Split the code snippet into lines
    lines = code_snippet.split('\n')

    # Flag to indicate if we're inside the dead() function
    inside_dead_function = False

    # Accumulator for the dead() function code
    dead_function_code = []

    # Track the number of opening and closing braces encountered
    brace_count = 0

    # Iterate through each line of the code snippet
    for line in lines:
        # Check if the line contains the dead() function definition
        if line.strip().startswith('void dead('):
            inside_dead_function = True

        # If we're inside the dead() function, accumulate the code
        if inside_dead_function:
            dead_function_code.append(line)
            # Update the brace count
            brace_count += line.count('{') - line.count('}')

            # If we have encountered more closing braces than opening braces,
            # it indicates the end of the dead() function
            if brace_count <= 0:
                inside_dead_function = False
                break

    # If the function definition is not found or the end brace is not found,
    # consider the last line of the snippet as the end of the function
    return '\n'.join(dead_function_code)

# Function to check if the braces are balanced in a code snippet
def are_brackets_balanced(content):
    index = 0
    brace_count = 0

    while index < len(content):
        if content[index] == "{":
            brace_count += 1
        elif content[index] == "}":
            brace_count -= 1

        # Optimization: Exit early if unbalanced braces
        if brace_count < 0:
            return False

        index += 1

    # Check if all braces are balanced
    return brace_count == 0

# Function to remove the main function from a C code snippet
def remove_main_function_c(code):
    start_index = code.find("int main")
    if start_index == -1:
        return code
    brace_start_index = code.find("{", start_index)
    if brace_start_index == -1:
        return code

    brace_count = 1
    index = brace_start_index + 1
    while index < len(code) and brace_count > 0:
        if code[index] == "{":
            brace_count += 1
        elif code[index] == "}":
            brace_count -= 1
        index += 1
    if brace_count == 0:
        code = code[:start_index] + code[index:]
    else:
        return code[:start_index]
    return code

# Function to clean up the code snippet by removing comments and unnecessary lines
def clean_up_code(code):
    lines = code.split('\n')
    cleaned_lines = []
    count = 0

    # Flag to keep lines after an open bracket
    keep_after_open_bracket = False

    for line in lines:
        # Skip lines starting with //
        if line.strip().startswith('//'):
            continue

        # Keep lines that start with #
        if line.startswith('#'):
            cleaned_lines.append(line)
            continue

        # Keep lines with brackets
        if '(' in line or ')' in line:
            if '{' in line:
                keep_after_open_bracket = True
                count += 1
            if '}' in line and count > 0:
                count -= 1
                if count == 0:
                    keep_after_open_bracket = False
            cleaned_lines.append(line)
            continue

        # Keep lines after an open bracket
        idx = 0
        while idx < len(line):
            if line[idx] == '{':
                keep_after_open_bracket = True
                count += 1
            idx += 1

        if keep_after_open_bracket:
            cleaned_lines.append(line)

            # Reset the flag after closing bracket is found
            idx = 0
            while idx < len(line) and count > 0:
                if line[idx] == '}':
                    count -= 1
                    if count == 0:
                        keep_after_open_bracket = False
                idx += 1

    return '\n'.join(cleaned_lines)

# Function to empty a folder
def empty_folder(folder_path):
    try:
        for root, dirs, files in os.walk(folder_path):
            for file in files:
                file_path = os.path.join(root, file)
                os.remove(file_path)
            for dir in dirs:
                dir_path = os.path.join(root, dir)
                shutil.rmtree(dir_path)
        print(f"The folder '{folder_path}' has been emptied.")
    except Exception as e:
        print(f"Error while emptying the folder: {str(e)}")

# Function to remove empty lines from the input text
def remove_empty_lines(text):
    """Remove empty lines from the input text."""
    lines = [line for line in text.splitlines() if line.strip()]
    return '\n'.join(lines)

# Core function to generate variations for the Block  
def Core():
    # Initialize the set to store generated variations
    Genarated_variations = set()
    print(f"Generating variations for Block...")
    start = datetime.datetime.now()
    print(f"Started at: {start}")

    file_path = f'{root_folder}/Block.c'
    if os.path.exists(file_path):
        os.remove(file_path)
    file_path =f'{folder_to_empty}/Block.c'
    if os.path.exists(file_path):
        os.remove(file_path)
    file_path = f'{root_folder}/Suggestions.txt'
    if os.path.exists(file_path):
        os.remove(file_path)

    # Running the Copilot automation executable
    executable_path =f'{root_folder}/CopilotAutomation.exe'
    print(f"Running Copilot for Block...")
    subprocess.run(executable_path, shell=True)
    print(f"Finished running Copilot for Block...")

    # Extracting suggestions from the generated Suggestions.txt file
    suggestion_objects = []
    with open(f'{root_folder}/Suggestions.txt', 'r', encoding='utf-8') as f:
        content = f.read()
    print(f"Extracting suggestions from Block...")
    # Use regular expressions to find content between each suggestion and its acceptance
    sugestions = re.findall(r'Suggestion \d+\n(.*?)\nAccept suggestion', content, re.DOTALL)
    for i, suggestion_content in enumerate(sugestions, start=1):
        suggestion_content = suggestion_content.strip()
        suggestion_objects.append(suggestion_content)
    Suggestions = []
    for suggestion in suggestion_objects:
        if are_brackets_balanced(suggestion):
            Suggestions.append(suggestion)
    for i in range(len(Suggestions)):
        Suggestions[i] = clean_up_code(Suggestions[i])
        Suggestions[i] = remove_main_function_c(Suggestions[i])
        if '{' in Suggestions[i]:
            Suggestions[i] = remove_empty_lines(Suggestions[i])
            fnc = extract_dead_function(Suggestions[i])
            head = extract_headers(Suggestions[i])
            head_str = "\n".join(head)
            Suggestions[i] = head_str + "\n" + fnc
            Genarated_variations.add(Suggestions[i])
    if len(Genarated_variations) == 0:
        print(f"No variations generated for Block.")
        return
    
    # Writing the generated variations to separate files
    for i,content in enumerate(Genarated_variations, start=1):
        file_path = f"{folder_to_empty}/Block-{i}.c"
        with open(file_path, "w") as file:
            file.write(content)
    end = datetime.datetime.now()
    print(f"Finished at: {end}")
    return
    



if __name__ == "__main__":
    input_var = 1
    Input_VAR = input_var
    if os.path.exists(folder_to_empty):
        empty_folder(folder_to_empty)
    else:
        os.makedirs(folder_to_empty)
    # Copy the Blocks.txt file to Input.txt for copilot processing
    shutil.copy2(r"C:\Users\Win10\Desktop\Integration\Server2\Code\Blocks.txt", r"C:\Users\Win10\Desktop\Integration\Server2\Code\Input.txt")
    Core()