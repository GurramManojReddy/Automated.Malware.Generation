import os
import itertools
import subprocess
import shutil

# Define the paths
path = r"C:\Users\Win10\Desktop\Integration\Server1\BuildingBlocks"
Code_folder = r"C:\Users\Win10\Desktop\Integration\Server1\Code"
combinations_folder = r"C:\Users\Win10\Desktop\Integration\Server1\Combinations"
Binary_folder = r"C:\Users\Win10\Desktop\Integration\Server1"
Main_function = r"C:\Users\Win10\Desktop\Integration\Server1\Main_Function.c"

# Function to count the number of folders in a directory
def count_folders(directory):
    contents = os.listdir(directory)
    folders = [item for item in contents if os.path.isdir(os.path.join(directory, item))]
    return len(folders)

# Function to prepend content to a file
def prepend_content(file_path, content_to_prepend):
    with open(file_path, 'r') as file:
        existing_content = file.read()
        # Add a newline between the existing content and the content to prepend
    content_to_prepend = content_to_prepend + '\n'
    content_to_prepend = content_to_prepend + '\n'
    new_content = content_to_prepend + existing_content
    with open(file_path, 'w') as file:
        file.write(new_content)

# Function to extract the code of a function from a C file
def extract_function_code(c_file_path, function_name):
    try:
        with open(c_file_path, 'r') as file:
            c_code = file.read()

        # Modify the function prototype to handle different return types
        start_marker = f"{function_name}\n{{"
        start_index = c_code.find(start_marker)
        
        if start_index == -1:
            return f"Function '{function_name}' not found in the C file."

        end_index = start_index
        brace_count = 0  # Keep track of nested curly braces

        for i in range(start_index, len(c_code)):
            
            
            if c_code[i] == '{':
                brace_count += 1
            elif c_code[i] == '}':
                brace_count -= 1
                if brace_count == 0:
                    end_index = i
                    break
        
        if brace_count != 0:
            return f"Function '{function_name}' has unbalanced curly braces."

        # Find the end of the function
        while end_index < len(c_code) and c_code[end_index] != '}':
            end_index += 1

        function_code = c_code[start_index:end_index + 1]
        return function_code

    except Exception as e:
        return f"Error reading or extracting code: {str(e)}"

# Function to extract headers from a C file
def extract_headers(c_file_path):
    try:
        with open(c_file_path, 'r') as file:
            c_code = file.read()

        # Initialize a list to store extracted headers
        extracted_headers = []

        # Define a marker for lines starting with #include
        include_marker = "#include"

        # Split the C code into lines
        lines = c_code.split('\n')

        for line in lines:
            if line.startswith(include_marker):
                extracted_headers.append(line)

        # Combine the extracted headers into a single string
        header_code = '\n'.join(extracted_headers)

        return header_code

    except Exception as e:
        return f"Error reading or extracting headers: {str(e)}"

# Function to merge two C files
def merge_files(file1_path, file2_path):
    extracted_header_code = extract_headers(file2_path)
    prepend_content(file1_path, extracted_header_code)
    with open(file1_path, 'a') as output_file:
        function_name = "int main()"
        extracted_code = extract_function_code(file2_path, function_name)
        output_file.write('\n')
        output_file.write(extracted_code + '\n')
        output_file.write('\n')

if __name__ == '__main__':
    # Create a list that stores the list of snippets from building blocks
    folder_snippets = []
    for folder_number in range(1, count_folders(path) + 1):
        folder_name = f"BuildingBlock-{folder_number}"
        folder_directory = os.path.join(path, folder_name)
        if os.path.exists(folder_directory):
            files = os.listdir(folder_directory)
            snippets = []

            for file_name in files:
                file_path = os.path.join(folder_directory, file_name)
                with open(file_path, 'r') as file:
                    snippet = file.read()
                snippets.append(snippet)
            folder_snippets.append(snippets)
    # Generating combinations of snippets
    combinations = list(itertools.product(*folder_snippets))
    count = 1
    for i, combination in enumerate(combinations):
        if i%100 == 0:
            print(f"Processing combination {i + 1}...")
        code_file_name = f"combination_{i + 1}.c"

        # creating the folders if they do not exist to store the code and binaries
        if not os.path.exists(Code_folder):
            os.makedirs(Code_folder)
        if not os.path.exists(Binary_folder):
            os.makedirs(Binary_folder)

        code_file_path = os.path.join(Code_folder, code_file_name)
        Binary_file_path = os.path.join(Binary_folder, f"combination_{i+1}")

        # Writing the combination to a file
        with open(code_file_path, 'w') as file:
            file.write('\n'.join(combination))
        merge_files(code_file_path, Main_function)
        try:
            result = subprocess.run(["gcc", code_file_path, "-o", Binary_file_path], check=True, stderr = subprocess.DEVNULL)
            if result.returncode == 0 and os.path.exists(Binary_file_path+".exe"):
                new_file_path = os.path.join(combinations_folder, f"Combination-{count}.c")
                shutil.move(code_file_path, new_file_path)
                os.remove(Binary_file_path+".exe")
                count += 1
        except subprocess.CalledProcessError as e:
            os.remove(code_file_path)

