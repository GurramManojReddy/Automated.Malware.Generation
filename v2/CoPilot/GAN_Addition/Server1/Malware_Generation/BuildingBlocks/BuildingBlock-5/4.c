//-----3-----

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
void DLL_Injection(char *dll, int process);
void DLL_Injection(char *dll, int process)
{
	HANDLE remote, thread;
	LPVOID mem;
	LPTHREAD_START_ROUTINE loadlib;
	HMODULE kernel32;
	DWORD len;
	remote = OpenProcess(PROCESS_ALL_ACCESS, FALSE, process);
	if (remote == NULL)
	{
		printf("[-] Error: Could not open process for PID (%d).\n", process);
		exit(1);
	}
	len = strlen(dll);
	mem = VirtualAllocEx(remote, NULL, len, MEM_COMMIT, PAGE_READWRITE);
	if (mem == NULL)
	{
		printf("[-] Error: Could not allocate memory inside PID (%d).\n", process);
		exit(1);
	}
	if (!WriteProcessMemory(remote, mem, dll, len, NULL))
	{
		printf("[-] Error: Could not write to allocated memory in PID (%d).\n", process);
		exit(1);
	}
	kernel32 = GetModuleHandle("kernel32.dll");
	if (kernel32 == NULL)
	{
		printf("[-] Error: Could not get handle to the DLL kernel32.dll.\n");
		exit(1);
	}
	loadlib = (LPTHREAD_START_ROUTINE)GetProcAddress(kernel32, "LoadLibraryA");
	if (loadlib == NULL)
	{
		printf("[-] Error: Could not get handle to the function LoadLibraryA.\n");
		exit(1);
	}
	thread = CreateRemoteThread(remote, NULL, 0, loadlib, mem, 0, NULL);
	if (thread == NULL)
	{
		printf("[-] Error: Could not create the remote thread.\n");
		exit(1);
	}
	printf("[+] Success: DLL injected via CreateRemoteThread().\n");
	printf("[+] Remote thread ID: 0x%X.\n", GetThreadId(thread));
}